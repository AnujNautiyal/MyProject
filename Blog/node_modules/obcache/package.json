{
  "name": "obcache",
  "version": "0.0.16",
  "description": "Object Caching",
  "main": "index.js",
  "scripts": {
    "test": "mocha -R spec ./test/test.js"
  },
  "author": {
    "name": "Qasim Zaidi"
  },
  "license": "BSD",
  "dependencies": {
    "sigmund": "~1.0.0",
    "lru-cache": "~2.3.1",
    "debug": "*",
    "redis": "*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/qzaidi/obcache.git"
  },
  "gitHead": "a6ddca4794c4800161e9608ffb209c5bf689f28d",
  "readme": "ObCache\n=======\n\nObCache is an Object caching module for node.js. Objects are cached in memory, via a backing store.\n\nCurrently 2 stores are supported.\n\n - Memory\n - Redis\n\nUse Redis for persistent caches.\n\nUsage\n------\n\n```\nvar obcache = require('obcache');\n\n// create a cache with max 10000 items and a TTL of 300 seconds\nvar cache = new obcache.Create({ max: 10000, maxAge: 300 });\n\n```\n\nThe max parameter above indicates the maximum keys that can be cached. If your values are variable sized and you want a finer control\non cache memory usage, specify maxSize instead. If no max is specified, max keys supported are Inifinity, and size\nof the cache will be governed by maxAge alone.\n\nThen wrap your original function like this\n\n```\nvar wrapper = cache.wrap(original);\n```\n\nNow call the wrapper as you would call the original\n\n```\nwrapper(arg1,arg2...argn,function(err,res) {\n  if (!err) {\n     // do something with res\n  }\n});\n```\n\nAPI\n---\n\n### obcache.Create\nCreates a new cache and returns it\n\n### cache.wrap \nWraps a given function and returns a cached version of it.\nFunctions to be wrapped must have a callback function as the last argument. The callback function is expected to recieve 2 arguments - err and data. data gets stored in the cache.\nSometimes, you may want to use a different value of this inside the caller function. cache.wrap has an optional second argument which becomes the this object when calling the original function.\n\nThe first n-1 arguments are used to create the key. Subsequently, when the wrapped function is called with the same n arguments, it would lookup the key in LRU, and if found, call the callback with the associated data. It is expected that the callback will never modified the returned data, as any modifications of the original will change the object in cache. \n\n### cache.warmup\nWarmup the cache.\n\nThe first argument is the cache function, and the last argument is the value. \n\nE.g.\n\n```\nvar myfunc = cache.wrap(function(q, r, cb) {\n  ...\n});\n\ncache.warmup(myfunc, q, r, 123);\n\n```\n\n### cache.invalidate\n\nInvalidate the cache contents. Subsequent calls will trigger a new fetch.\n```\ncache.invalidate(myfunc,q,r);\n```\n\n### cache.debug\n\nThe debug interface exposes 2 functions, register and view. register is used to register a cache for debugging. view is a connect middleware that can be used to view all the registered caches and their data/keys.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/qzaidi/obcache/issues"
  },
  "homepage": "https://github.com/qzaidi/obcache#readme",
  "_id": "obcache@0.0.16",
  "_shasum": "c67e19802aba14999500916a7988e9635c9196c7",
  "_from": "git://github.com/paytm/obcache.git",
  "_resolved": "git://github.com/paytm/obcache.git#a6ddca4794c4800161e9608ffb209c5bf689f28d"
}
